[{"body":"The WorkflowFM Composer client is built using Java 11 and Gradle.\nIt requires a running instance of the server, with an accessible host and port.\nThis section covers installation and running.\n","link":"https://docs.workflowfm.com/workflowfm-composer/client/getting-started/","title":"Getting Started"},{"body":"To install, you can either grab the pre-built zip file or build the client yourself.\nRelease Install simply by grabbing the zipped distribution from the latest release and unzip to your chosen location.\nManual build The client can be built manually using Gradle, which ships with the repository.\nYou can use either:\n Pre-installed Gradle: gradle Linux: ./gradlew Windows: gradlew.bat  Building requires JDK 11 or above.  The client can be compiled and packaged with a single command:\n1gradle :client:distZip This will create the file client/build/distributions/WorkflowFM_Composer-@@.zip.\nUnzip it to your favourite location to obtain a client installation.\n","link":"https://docs.workflowfm.com/workflowfm-composer/client/getting-started/install/","title":"Install"},{"body":"Start the Client using (Linux/Mac):\n1./bin/WorkflowFM_Composer or similarly in Windows:\n.\\bin\\WorkflowFM_Composer.bat Once loaded, enter the address and port of the server in the dialog provided:\n If the client is able to connect to the server, you will see the full client interface:\n ","link":"https://docs.workflowfm.com/workflowfm-composer/client/getting-started/run/","title":"Run"},{"body":"This section covers basic usage of the client.\n","link":"https://docs.workflowfm.com/workflowfm-composer/client/use/","title":"Usage"},{"body":"A quick overview of some of the features is described in the following tasks:\nCreate  Click on the  Create Process icon. Double click on the process box labelled P1 to rename the process. Double click on one of the edges (initially labelled X) to rename the corresponding resource. Double click on one of the small, resource circles to add a new branch. Right-click on one of the small, resource circles to add a branch of different type (from parallel to optional and vice-versa) or to delete a branch.  Compose  Open a new workspace with the  Create Workspace icon. Double click on a process in the Processes list on the left to add its graph to the workspace. Compose processes in sequence by selecting (clicking) an output resource (edge or circle) and then right-clicking an input resource with the same name belonging to a different process. Compose processes in parallel by selecting (clicking) a process box then right-clicking another process box. Compose processes conditionally by selecting (clicking) an input resource (edge or circle) and then right-clicking another input resource belonging to different process. Right click on a process box and select  Store Composition to collapse and *store a composite proces*s as a reusable composite component under a new name.  Edit \u0026amp; Verify  Right click on a process in the Processes list on the left. Select  Edit Process to change the specification of an atomic process. Select  Delete Process to delete a process. Changing or deleting a process specification affects all composite processes that depend on it. These become unverified:  . Right click on an unverified process and select  Verify Process\u0026amp;Parents to rerun and verify the composition.  ","link":"https://docs.workflowfm.com/workflowfm-composer/client/use/quick/","title":"Quick Start"},{"body":" Clicking on the  Create Process icon at any time opens a new window for creating a new atomic process. Right-clicking on an atomic process in the Processes list on the left and then clicking the  Edit Process option opens the same window to allow edits.  The available functionality is described below.\nActions can be undone/redone at any time using the undo/redo arrows at the top, or Ctrl-Z and Ctrl-Y respectively.\nClick the Done button at the bottom when all the desired edits are completed. This will create the new process or update the one being edited.\nNew and edited atomic processes are added to the Processes list on the left.\nEditing an atomic process that is used in some composition may render that composition invalid (unverified). The composition will need to be verified again with the new atomic specification.  Process names An initial, unique name P# is automatically generated for the process.\nProcess names must start with a letter and may only contain letters, numbers and underscores.  A process can be renamed in 2 ways:\n By clicking the  Rename icon. By double clicking the blue box containing the name of the process.  It is standard practice in process modelling to name processes using verbs that describe the corresponding action being taken. For example: CreateAccount, GenerateReport, CheckOutcome.  Resource names Resource names describe the types of input or output resources for a process.\nResource names must start with a letter and may only contain letters, numbers and underscores.  A resource can be renamed by double clicking the edge (line) that carries its name.\nIt is standard practice in process modelling to name resources using nouns that describe the corresponding concrete or abstract resource. For example: CreatedAccount, GeneratedReport, Payment.  Resource branches Both input and output resources can be added as branches in a tree-like structure. A dialog to fill in the name of the newly added resource is provided each time.\nWe can specify branches of both parallel (solid lines) and optional (dashed lines) resources.\nOptional resources are exclusively so, meaning that only one of the optional branches will be provided at runtime.    Double-clicking on a blue resource circle adds a new resource at the same level and branch type as the circle.\nFor example, if a circle belongs to an optional branch (dashed line), double clicking it will produce a new option from the same root as the circle.\n  Right-clicking on a blue resource circle reveals the  Add branch option. Selecting this will add a new resource branch of the opposite type to that circle.\nFor example, if a circle belongs to an optional branch (dashed line), the Add Branch option will add a new parallel branch starting from that circle and including the original resource (or its children) and the new resource as children.\nThis allows us to change the type of a branch and alternate between parallel and optional branching.\n  Right-clicking on a blue resource circle also reveals the  Delete branch option. Selecting this will delete the resource or the entire branch of resources belonging to the circle.\nThis may lead to branches of the same type collapsing together in a single branch.\nAs with all other edit actions, this action can be undone.\n  ","link":"https://docs.workflowfm.com/workflowfm-composer/client/use/edit/","title":"Create \u0026 Edit"},{"body":"Composition involves the combination of 2 processes (binary compositions) in a single composite process.\n This requires an active Workspace. A new workspace can be created using the  Create Workspace icon. Processes can be added to the workspace by double-clicking them in the Processes list on the left or by right-clicking them and selecting the  Add Graph option.  Once added, processes can be composed together in 3 ways:\n In sequence In parallel Conditionally  All composition actions are performed in 2 steps: first select (left-click) on an element and then right-click on a target element to compose them together. The selection is different for each action, as described below.\nEach time a composition action is performed successfully, a new intermediate composition is created and listed in the Compositions list on the left.\nEach workspace has its own Compositions list. Make sure you have an active workspace to view its list. You may need to drag and resize the list using the bar at the bottom of the Processes list to make it visible.  Intermediate compositions are named automatically as _Step# using a unique number (wHith separate counting for each workspace). These can be used as components in further composition actions. They cannot be renamed, but they can be stored as new processes.\nIn some cases and due to certain design decisions (some of which are mentioned below), the result of a composition action may seem bizarre or unexpected. However, every composition action is performed using formal, logic-based reasoning and is guaranteed to be correct.\nFor example, the reasoner guarantees systematic resource accounting, so that unused resources (for example in sequences of optional processes) may appear as new outputs.\nIn Sequence Composing 2 processes in sequence creates a composition where the output of one process connects to an input of the same type of another process. This is the most common composition action.\n This can be accomplished by seleting a input/output resource and then right-clicking on a corresponding output/input resource of another process.  The UI helps identify valid targets for sequential composition:\n Hovering above a resource highlights matching targets using orange boxes. Selecting a resource highlights matching targets using dark green boxes until the resource is de-selected.  Sequential composition attempts to work maximally and connect together as many of the matching resources as possible.  For example, consider a process with parallel outputs A and B, and another process with corresponding parallel inputs A and B. We can compose them in sequence by selecting the output A of the first process and right-clicking on the input A of the other. Even though we selected A for composition, both A and B will be connected in the resulting composite process.\nThe rationale for this design choice is beyond the scope of this documentation, but we refer the interested reader to the relevant publication.\nAn example sequential composition, with the orange highlight boxes, is shown below:\n In Parallel Composing 2 processes in parallel groups them together in a composite process that executes them both at the same time. The resulting composition has all of the inputs and all of the outputs from both processes.\n This can be accomplished by selecting a blue process box and then right-clicking on a different blue process box.  A triangle join node will appear in the composite process in this case.\nConditionally The conditional composition of 2 processes leads to a composite process where only one of the 2 processes will be executed depending on runtime conditions. This type of composition is useful in cases where each of the components of an optional output of a process needs to be handled by a different receiving process.\nWhich process is executed is dictated by a new optional input, using one input from each process. If the first option is provided (at runtime), the first process will be executed, whereas if the second option is provided, the other process will be executed.\n This can be accomplished by seleting an input resource and then right-clicking on an input resource of another process.  One or more diamond with nodes may appear in the composite process in this case.\n","link":"https://docs.workflowfm.com/workflowfm-composer/client/use/compose/","title":"Compose"},{"body":"Store Storing an intermediate composition allows the creation of a new, composite process that can be reused in the same way as atomic processes.\nThe expectation here is that the user composes processes together using composition actions and generating intermediate compositions. Once they are happy with a particular composition and they want to keep it for further use as a new process, they can store it.\n This can be accomplished by right clicking on an intermediate composition of a workspace in the Compositions list on the left. Then select the option  Store Composition.  A new window will be opened, showing the graph of the selected composition:\n A new, unique name must be provided for the composite process, following the same rules and practices as for atomic process naming.\nClicking on the Done button at the bottom of the window completes the storage process. The new composite process should appear in the Processes list on the left.\nVerify Verifying a process involves sending its specification to the reasoner and verifying its correctness.\nThere are several options to verify different processes:\n The  Verify All icon attempts to verify all atomic and composite processes. This can be particularly useful in a newly opened file. The  Verify All Intermediates icon attempts to verify all intermediate processes in an active workspace. Right-clicking an atomic or composite process and selecting the  Verify Process option verifies the selected process only. Right-clicking an intermediate composition and selecting the  Verify Composition option verifies the selected composition only. Right-clicking an atomic or composite process or an intermediate composition and selecting the  Verify Process\u0026amp;Parents option verifies all of the components of the selected process recursively and then the process itself.  These options allow a step-by-step verification process in case the exact source of an error needs to be identified.\nVerification may be required in several situations where a process specification may have changed either directly or indirectly because of another process. Typical examples include:\n Loading a saved file. Editing or deleting a component atomic process. Replacing/updating a component atomic or composite process.  If there is uncertainty about the correctness of a process, it is marked as unchecked or unverified. This is indicated by a yellow warning icon as shown below.\nIf verification of a particular composition fails (for instance because a composition action is no longer possible), the corresponding reasoner error will be displayed and the process will be marked as invalid with a red icon as shown below.\n   Icon Decription       Unchecked atomic process     Unchecked composite process     Unchecked intermediate composition     Invalid atomic process     Invalid composite process     Invalid intermediate composition    ","link":"https://docs.workflowfm.com/workflowfm-composer/client/use/verify/","title":"Store \u0026 Verify"},{"body":"The reasoner can automatically generate executable Scala code for process compositions, including code templates for the involved resource types and atomic processes.\nThe code relies on the use of the WorkflowFM PEW execution engine.\n This can be accomplished by right-clicking on a composite process and selecting the  Deploy in Scala option.  This will open a new window with the appropriate dialog for deploying code. Using the Ski example, the window is shown below:\n Roadmap The reasoner is able to automatically generate workflow code that corresponds to the verified composition.\nThe roadmap of that process is as follows:\n Composing atomic processes in the WorkflowFM reasoner results in a correct-by-construction π-calculus specification. This essentially describes the appropriate connections between the component processes so that they are executed in the right order and in an asynchronous way. The π-calculus specification of a composition can be automatically translated in Scala code for the PEW engine.\nAtomic components are originally defined in an abstract way by the user. The code generated for them consists of an abstract trait with the appropriate function type, such that fits the formal input and output specification. The user should then provide concrete implementations for those traits to complete the deployment.\nIn addition, the resource types are also introduced in an abstract way. The user is required to instantiate those abstract types with concrete Scala types.\nIn summary, here are the necessary steps to complete a deployment:\n Set up a project template (see below). Deploy the required composite processes. Instantiate the resource types. Provide concrete instances of the atomic components. Execute.  Project template Although not strictly necessary, it is convenient to first set up a Scala project using sbt before deploying the code.\nThis is greatly facilitated by the provided WorkflowFM Giter8 template for PEW. Assuming a working installation of sbt, you can set a project up using the following command:\n1sbt new workflowfm/pew-deploy.g8 This will prompt you for a project name (among other options) and will build a directory with that name.\nYou can then deploy the generated code in the *projectname*/src/main/scala directory.\nUse sbt to compile and run your new project.\nConfiguration The deployment dialog requires the following configuration options:\n Project name: A general name for the project. This is used to name some of the higher level srructures in the code, such as the object containing the types. Process: The stored composite process you want to deploy. Target directory: The directory where the code will be placed. Package: The name of the top level Scala package (namespace) in which the code should belong. Use Stateful library: This should always be ticked in order to use the PEW library. Otherwise a deprecated/legacy library will be used. Create Main class: Choose whether a template of a class containing a main method, such that instantiates and executes one instance of the deployed workflow, should be generated.  Once all the desired options are in, click on the Done button at the bottom of the window to start the deployment.\nDeployment of multiple compositions is not explicitly supported. However, it is safe to deploy more than one composition with the same option. Care must taken to ensure all resource types are instantiated. Uninstantiated types will be detected by the Scala compiler. We have plans to support larger and more complex deployments in future versions.  Output The output of the deployment is shown in the Deployment Log at the bottom half of the window. It can be split in 4 types:\n Processes (in the processes sub-package): Automatically generated code for each process. This is overwritten in every new deployment, so no user editing is expected here. Instances (in the instances sub-package): Templates for the atomic components. These are expected to be filled in with code by the user. In case of a redeployment, these are not overwritten so as not to delete user code. However, extra care must be taken to ensure that a previously implemented process adheres to any changed specifications. Types (in the top level package): A package object including aliases of all required resource types as strings. The user can edit these to use their desired types. This file is also not overwritten. Main (in the top level package if selected): A class with a sample main method that instantiates and runs a single instance of the deployed workflow. This file is also not overwritten.  ","link":"https://docs.workflowfm.com/workflowfm-composer/client/use/deploy/","title":"Deploy"},{"body":"Some other available functionality is described here.\nShow Graph Once a composite process or an intermediate composition is created, its graph can be viewed on a separate window.\n This can be accomplished by right-clicking the composition and selecting the  Show Graph option. The full graph is also shown when hovering above the blue process box of a (collapsed) composite process.  This can be particularly useful for composite processes which appear as a single atomic process in subsequent compositions.\nLoad Compositions In some cases it may be useful to reload the intermediate (binary) composition steps that we followed when a composite process was stored.\n This can be accomplished by right-clicking a composite process and selecting the  Load Compositions option.  This will create a new workspace and add all the composition steps used to create the selected process as intermediate compositions.\nThis can be particularly useful for example when a composite process has become invalid due to an updated component and you need to adjust the composition actions, or if a similar copy of the same composition is required, but the workspace no longer exists.\nInspect π-calculus The reasoner automatically produces π-calculus specifications of the specified processes. These can be visualized and inspected using the PiVizTool, which has been directly integrated with the Client.\nThe PiVizTool relies on GraphViz. The dot executable must be available in the PATH for it to function.   This can be accomplished by right-clicking the composition and selecting the  Inspect pi-calculus option.  The graph includes a Request and a Response process, which are responsible for the sending the initial inputs and receiving the final outputs respectively.\nUsing the Ski example, the PiVizTool window is shown below:\n The visualization is interactive. Resources are communicated between processes by clicking on black edges or using the icons at the top.\nSome familiarity with π-calculus is required to be able to follow the execution steps.\nThe PiVizTool has certain bugs which sometimes cause it to fail and give an error despite a valid pi-calculus specification. Unfortunately we have not been able to identify the source or resolve these issues.  ","link":"https://docs.workflowfm.com/workflowfm-composer/client/use/other/","title":"Other"},{"body":"This section covers a reference to elements of the client, including examples, graph elements, and configuration values.\n","link":"https://docs.workflowfm.com/workflowfm-composer/client/reference/","title":"Reference"},{"body":"A list of examples is available in the default installation of the client. You can inspect them by loading the corresponding file, verifying all processes and compositions and viewing their graphs.\nThe following examples are included:\n  SimpleCopyAndSequence.json: Simple example demonstrating the copy node and 2 separate methods of serial sequential composition. Inspection of the graph and underlying π-calculus structure shows the difference between composing right-to-left (simpler structure) and left-to-right (introduces axiom buffers).\n  SimpleOptionalTreatment.json: Simple healthcare-inspired example demonstrating resource accounting when handling optional/exceptional outcomes as presented in:\n A Pragmatic, Scalable Approach to Correct-by-construction Process Composition Using Classical Linear Logic Inference    BuySki.json: Example of a workflow for buying Ski equipment as presented in:\n A theorem proving framework for the formal verification of Web Services Composition    HomePurchase.json: Example of a workflow for purchasing property as presented in:\n Formal verification of Web Services composition using linear logic and the pi-calculus    HealthcareHandover.json: Example of 2 patient handover workflows via assignment and delegation, as presented in:\n Formal verification of collaboration patterns in healthcare Rigorous process-based modelling of patterns for collaborative work in healthcare teams    ","link":"https://docs.workflowfm.com/workflowfm-composer/client/reference/examples/","title":"Examples"},{"body":"The following is a complete list of the visual elements, including nodes (vertices) and edges, that can be encountered in a process graph.\nVertices    Name Visual Description     Resource    An input or output resource.   Atomic Process    An atomic process.   Composite Process    A composite process.   Copy node    A process with a single input and multiple parallel outputs of the same type is assumed to be a copy process that makes multiple copies of its input.   Join node    A special node used when the output of a composite process does not have a single or clear source.   Merge node    A special node used when an optional input/output combines resources from multiple component processes.    Edges Edges can be solid or dashed as shown below:\n Dashed edges are used to indicate that the corresponding resource (or group of resources) is optional, i.e. part of an optional tree of resources where only one of the branches can be provided.\n","link":"https://docs.workflowfm.com/workflowfm-composer/client/reference/graph/","title":"Graph elements"},{"body":"Configuration values are stored in a .workflowfm directory at the user's home directory, defaulting in the composer.properties file.\nIt is not necessary to explicitly set any of these configuration parameters, but it is possible to tweak the behaviour of the client in some ways if desired.\n You can manually set parameters in the configuration file following the standard .properties file format, variable = value. You can also create a custom property file to be used instead of the default file. Simply pass the file path as an argument when starting the client.  Some values may be changed through the use of the interface and will be overwritten in the file. These are marked in the Auto column below.\n   Parameter name Type Description Default Auto     processNodeWidth * Integer The pixel width of the process vertex. 120    processNodeHeight Integer The pixel height of the process vertex. 40    processNodeAutoResize Boolean If true the width of process vertices is resized to fit their label. true    processCopierNodeRadius Integer The pixel radius of the copier node vertex. 15    interHierarcySpacing Integer The vertical distance between 2 separate process graphs. 40    interRankCellSpacing Integer The horizontal distance between 2 vertices of the same process graph. 110    atomicProcessColour String (hex colour) The colour of an atomic process vertex. #BBDEFB    compositeProcessColour String (hex colour) The colour of a composite process vertex. #64B5F6    portEdgeColour String (hex colour) The colour of a resource vertex. atomicProcessColour    edgeColour String (hex colour) The colour of a solid edge. #686868    bufferColour ** String (hex colour) The colour of a buffer edge. #686868    hoverHighlightColour String (hex colour) The colour used to highlight matching resource vertices when hovering above one. #F78400    selectHighlightColour String (hex colour) The colour used to highlight selected vertices. #33691E    proofScriptDirectory String (directory) The default directory for opening files. ./proofs/     imageDirectory String (directory) The default directory for storing screenshots. proofScriptDirectory     frameWidth Integer The width of the UI window. (Attempts to resize to that on start.) 1000     frameHeight Integer The height of the UI window. (Attempts to resize to that on start.) 1000     deployStateful Boolean The default value of the corresponding tick box in the deployment dialog. true     deployMain Boolean The default value of the corresponding tick box in the deployment dialog. true     projectName String The last used project name in the deployment dialog.      deployPackageName String (Scala package) The last used package name in the deployment dialog. com.workflowfm.project     deployFolder String (directory) The last used target directory in the deployment dialog. ./     server String (host/IP) The last used server host/IP. localhost     port Integer (port) The last used server port. 7000     serverMaxAttempts Integer The maximum number of attempts to reconnect to the server upon failure. 10      * The value processNodeWidth is unimportant if processNodeAutoResize is true. ** Buffer edges were originally used to represent resources that are not directly connected to a process, but go through the so-called axiom buffers. In more recent versions of the system, we considered this information more confusing than helpful, so we use the same colour for those edges. Moreover, the algorithm that determines which resources are buffered is not always accurate. Because of this, the value bufferColour will be deprecated in future versions. The value of bufferColour should normally be the set to be the same as edgeColour.  ","link":"https://docs.workflowfm.com/workflowfm-composer/client/reference/configuration/","title":"Configuration"},{"body":"Docker helps automate the deployment of the server and the complexity of the reasoner in particular.\nYou can use the published image or build it yourself.\n","link":"https://docs.workflowfm.com/workflowfm-composer/server/docker/","title":"Docker"},{"body":"The easiest setup of the server is using the latest available Docker image.\nPull the image using:\n1docker pull ghcr.io/workflowfm/composer-server:latest Then run a container using:\n1docker run -p 7000:7000 --name workflowfm-server --detach ghcr.io/workflowfm/composer-server:latest  The name workflowfm-server is optional and can be changed to whatever you want your server container to be named. The port can also be bound to a different system port, e.g. using -p 9000:7000 to bind it to port 9000.  The container may take a few minutes to fully start!  This is because it loads HOL Light and the WorkflowFM Reasoner from scratch. You can follow progress using:\n1docker logs --follow workflowfm-server ","link":"https://docs.workflowfm.com/workflowfm-composer/server/docker/image/","title":"Quick Setup"},{"body":"You can build the Docker image yourself from source.\nFirst, clone the repository:\n1git clone https://github.com/workflowfm/workflowfm-composer.git Make sure to recursively populate submodules:\n1cd workflowfm-composer/ 2git submodule update --init --recursive --depth 1 Then build the image with the provided Dockerfile:\n1docker build -t composer-server . Then run a container using:\n1docker run -p 7000:7000 --name workflowfm-server --detach composer-server  The name workflowfm-server is optional and can be changed to whatever you want your server container to be named. The port can also be bound to a different system port, e.g. using -p 9000:7000 to bind it to port 9000.  The container may take a few minutes to fully start!  This is because it loads HOL Light and the WorkflowFM Reasoner from scratch. You can follow progress using:\n1docker logs --follow workflowfm-server ","link":"https://docs.workflowfm.com/workflowfm-composer/server/docker/build/","title":"Build Image"},{"body":"A manual build is also possible, albeit more tedious.\nIt requires a local installation of the WorkflowFM Reasoner, in addition to building and running the server itself.\n","link":"https://docs.workflowfm.com/workflowfm-composer/server/manual/","title":"Manual Build"},{"body":"The server can be built using Gradle, which ships with the repository.\nYou can use either:\n Pre-installed Gradle: gradle Linux: ./gradlew Windows: gradlew.bat  Building requires JDK 11 or above.  The server can be compiled and packaged with a single command:\n1gradle :server:distZip This will create the file server/build/distributions/WorkflowFM_Server-{VERSION}.zip.\nUnzip it to your favourite location to obtained a server installation.\n","link":"https://docs.workflowfm.com/workflowfm-composer/server/manual/server/","title":"Server"},{"body":"Installation The WorkflowFM Reasoner can be installed following the instructions in its documentation.\nThe involved hol-light repository can already be found as a submodule under server/hol-light.\nUsing checkpointing, if possible, can help build a server that runs instantly.\nLaunch script Once the reasoner is installed and working, we need to build a script that runs the reasoner and pipes the input/output to the server.\nThe scripts/ directory contains bash scripts that can help achieve this. Both scripts assume that the reasoner is installed in a hol-light/ directory within the server installation. If that is not the case, this can be adjusted using a symbolic link:\n1ln -s full/path/to/reasoner hol-light   If checkpointing (dmtcp) was used, the reasoner can run using ./scripts/launch_prover_local.sh.\n  If checkpointing is not available, you can use ./scripts/launch_prover_docker.sh which is what the Docker build uses to load HOL Light and the reasoner from scratch.\n  You can also run the reasoner on a remote machine using an ssh tunnel. This assumes an installation of the server and the reasoner on that machine, the use of checkpointing, and password-less ssh access to the remote machine. In that case you can use ./scrips/setup_remote_prover.sh to create a remote launch script (./scripts/launch_prover.sh), using the url of the remote machine and the absolute path to the installation of the reasoner:\n1./scripts/setup_remote_prover.sh someuser@host.of.reasoner.com /home/someuser/workflowfm-server/scripts/launch_prover_local.sh Make sure you run the corresponding script and verify it does load the reasoner correctly and without errors. The reasoner should run through the script and allow you to issue OCaml toplevel commands. It should react (and exit) if you provide the following command:\n1exit(0);;   ","link":"https://docs.workflowfm.com/workflowfm-composer/server/manual/reasoner/","title":"Reasoner"},{"body":"Configuration Running the server requires a .properties configuration file with 3 elements:\n server: The host name (default: localhost). port: The port to bind to for listening (default: 7000). launchProverCommand: The location of the script to run the reasoner.  The contents of the docker.properties file, which is used in the Docker image, is shown as an example below:\n1server=localhost 2port=7000 3launchProverCommand=/server/scripts/launch_prover_docker.sh Launch To summarize, running the server requires the following:\n An installation of the Java server. A working installation of the reasoner. A configuration file.  With everything in place, the server can be run from its installation with the following command:\n1./bin/WorkflowFM_Server /path/to/configuration/file.properties ","link":"https://docs.workflowfm.com/workflowfm-composer/server/manual/run/","title":"Run"},{"body":"Welcome to the WorkflowFM Composer Client documentation.\nThe Client provides a Java-based Graphical User Interface or formally verified process composition using the WorkflowFM Reasoner.\nThe Client requires a running instance of the Server.  It allows the specification of processes using their input and output resources. Processes can then be composed together with simple mouse gestures. Every composition action is sent to the reasoner, via the server, and then performed using logic-based reasoning so that the result is formally verified.\nConfiguration values are stored in the user's home directory, under .workflowfm/.  Get started ","link":"https://docs.workflowfm.com/workflowfm-composer/client/","title":"Client"},{"body":"Welcome to the WorkflowFM Composer Server documentation.\nThe Server provides an intermediate layer between the WorkflowFM Reasoner and the Client. It exposes a raw socket to allow the client to communicate remotely with the reasoner.\nThe server is currently insecure for public use. Avoid deploying it in a public server or outside a firewall.  The reasoner is based on HOL Light, which runs on the OCaml toplevel. This makes it difficult to manage in a scalable way and to connect to it remotely or through the web. It also limits its usage to a single user. The server addresses these issues by managing connections through a raw socket and queueing requests to the reasoner.\nThe server can be deployed either manually or through Docker. Using the existing Docker image makes things much easier, but this documentation covers a few different ways to build and deploy it.\nOnce the server is deployed, you can run an connect multiple clients to it.\nGet started ","link":"https://docs.workflowfm.com/workflowfm-composer/server/","title":"Server"},{"body":" \nA diagrammatic tool for formally verified process modelling and composition.  Client DocsServer DocsSource\nAbout The WorkflowFM Composer consists of a Java-based server and GUI for formally verified process composition using the WorkflowFM Reasoner. It provides a visual, diagrammatic interface to specify processes based on their input and output resources, and compose them together to form more complex workflows.\nActions in the GUI of the Client are sent to the Server, which in turn is able to interact directly with the Reasoner. The Reasoner then performs the necessary logic-based inference within the rigorous environment of the HOL Light theorem prover.\nThe end result is a composite process that is provably correct and has the following properties:\n Systematic resource accounting: No resources appear out of nowhere or disappear into thin air. Deadlock and livelock freedom: The constructed workflows can be executed without fear for deadlocks or livelocks. Type checked composition: The correctness of the types of all connected resources is ensured via the logical proof. Fully asynchronous and concurrent execution: During workflow execution, each component process can be executed fully asynchronously (see the PEW engine for more details) and concurrently, without introducing any conflicts, race conditions, or deadlocks.  Key Features  Visual specification of processes based on ther input and output resources. Intuitive gestures for process composition. Formally verified composite processes based on rigorous logic-based reasoning. Simplified diagrammatic representation of complex logic-based deduction. Automated tracking of unused resources in compositions. Highlighting of matching resources. Workspaces for the development of multiple compositions at the same time. Workflow visuazliation using the PiVizTool. Export Scala code to execute workflows using the PEW engine. Export of PNG images.  \nAuthors Maintainer Petros Papapanagiotou -  -  - \nContributors A big thank you to the following contributors in order of appearance:\n Jacques Fleuriot -  Sean Wilson -  James Vaughan Filip Smola  Groups \u0026amp; Organizations   Artificial Intelligence Modelling Lab   Artificial Intelligence and its Applications Institute   School of Informatics, University of Edinburgh    \nReferences Please cite the following publication in reference to this project:\n P. Papapanagiotou, J. Fleuriot. WorkflowFM: A Logic-Based Framework for Formal Process Specification and Composition. CADE, 2017.  Sample of other relevant references:\n P. Papapanagoiotou, J. Fleuriot, S. Wilson. Diagrammatically-driven formal verification of Web-Services composition. Diagrams, 2012. P. Papapanagiotou. A formal verification approach to process modelling and composition. PhD Thesis, 2014.  License Distributed under the Apache 2.0 license. See LICENSE for more information.\nCopyright © 2009-2021 The University of Edinburgh and contributors\n","link":"https://docs.workflowfm.com/workflowfm-composer/","title":"WorkflowFM Composer"}]