/* Generated By:JJTree: Do not edit this line. ASTComposition.java */

package piviz.executionEngine;


import java.util.ArrayList;
import java.util.Hashtable;

import piviz.exceptions.PiExecutionException;
import piviz.exceptions.RestrictionTableException;
import piviz.helperClasses.PidGenerator;
import piviz.helperClasses.RestrictionTable;


/**
 * Node representing the parallel execution of processes/subprocesses.
 * 
 * @author Anja
 * 
 */
public class ASTComposition extends SimpleNode {
	public ASTComposition(int id) {
		super(id);
	}

	public ASTComposition(PiParser p, int id) {
		super(p, id);
	}

	/**
	 * Make a copy of this subtree. This includes creating a new Composition
	 * node and calling this method for all its children.
	 * 
	 * @return Pointer to the root of the new subtree.
	 */
	public SimpleNode copySubtree(String postFix) throws PiExecutionException {

		ASTComposition cNode = new ASTComposition(
				PiParserTreeConstants.JJTCOMPOSITION);
		cNode.setProcessName(this.getProcessName()+postFix);
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					cNode.jjtAddChild(n.copySubtree(postFix), i);
				}
			}
		}
		return cNode;
	}

	/**
	 * The composition node can be resolved during the get action command. This
	 * action includes resetting the pids of the subprocesses to different pids
	 * and updating the restriction table concerning the new pids. Afterwards
	 * the composition node is removed from the execution tree and its children
	 * are added.
	 */
	public void getAction(boolean blockExecution,
			SimpleNode defTreeRoot, Hashtable resultVector, SimpleNode parent,
			RestrictionTable resTable) throws PiExecutionException, RestrictionTableException {

		// set the parent of this node
		this.jjtSetParent(parent);

		// do not execute if this node is a descendent of a replication node
		if (!blockExecution)
			resolveComposition(resTable);
		/*
		 * If it is a descendent of a replication node just collect the actions.
		 */
		else {
			for (int i = 0; i < this.jjtGetNumChildren(); i++) {
				SimpleNode n = (SimpleNode) this.jjtGetChild(i);
				if (n != null)
					n.getAction(blockExecution, defTreeRoot, resultVector,
							this, resTable);

				/*
				 * getAction could have removed the child node n, this has to be
				 * checked and in case of removal the index has to be adjusted,
				 * so every child is handled.
				 */
				if (this.jjtGetChild(i) != n)
					i--;
			}
		}
	}

	/**
	 * Execution assigns new pids to the sub processes and replaces the old pids
	 * entry in the restriction table. One of the two parameters will be null,
	 * this is needed to find the right process for further execution.
	 */
	public void executeNode(SimpleNode node, RestrictionTable resTable)
			throws PiExecutionException, RestrictionTableException {
		// First go all the way up and execute the ancestors of this node.
		super.executeNode(node, resTable);

		// Now the parent should be the root node
		if (!this.parent.toString().equals("Root"))
			throw new PiExecutionException(toString()
					+ " executeNode(): Parent was expected to be Root.");

		resolveComposition(resTable);

	}

	/**
	 * Resolve Composition does the actual execution of the node. It includes
	 * resetting the pids of the subprocesses to different pids and updating the
	 * restriction table concerning the new pids. The subprocesses are added to
	 * the parent of this node. Afterwards the composition node is removed.
	 * 
	 * @param resTable
	 *            Reference to the table where the restrictions are stored, that
	 *            have to be updated.
	 */
	private void resolveComposition(RestrictionTable resTable)
			throws PiExecutionException, RestrictionTableException {
		// Now resolve the composition
		ArrayList newPids = new ArrayList();
		for (int i = 0; i < this.jjtGetNumChildren(); i++) {
			// reset pid of child
			SimpleNode n = (SimpleNode) children[i];
			if (n != null) {
				String oldPid = n.getPid();
				String newGenPid = PidGenerator
						.generateNewPidFromOldOne(oldPid);
				n.setPid(newGenPid);
				newPids.add(newGenPid);

				/*
				 * Add the changed subtree as a child to the execution tree at
				 * relatively the same position where the composition node was,
				 * it will be further traversed for getting the actions later
				 * on.
				 */
				((SimpleNode) parent).insertChild(n, this.parent.jjtGetNumChildren());
				// int newIndex = parent.jjtGetNumChildren();
				// parent.jjtAddChild(n, newIndex++);
				// n.jjtSetParent(parent);
			}

		}
		// update restriction table concerning pids
		resTable.replacePid(this.getPid(), newPids);

		// remove this node
		((SimpleNode) parent).removeChild(this);
	}
	
	/**
	 * Add this node to the list and go further up if possible.
	 */
	public void getAncestorCompositionNodes(ArrayList compNodes) {
		compNodes.add(this);
		super.getAncestorSummationNodes(compNodes);
	}
	
	/**
	 * Get the process definition of this node and its subnodes and return it.
	 * @return
	 */
	public String getProcessDefinitions(){
		String str = "";
		for (int i = 0; i < this.jjtGetNumChildren(); i++){
			SimpleNode n = (SimpleNode)this.jjtGetChild(i);
			if (n != null){
				if (str.equals(""))
					str = str + "(";
				else str = str + " | ";
				
				str = str + n.getProcessDefinitions();
			}
		}	
		str = str + ")";
		return str;
	}
}
