/* Generated By:JJTree: Do not edit this line. ASTRestriction.java */

package piviz.executionEngine;


import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;

import piviz.exceptions.PiExecutionException;
import piviz.exceptions.RestrictionTableException;
import piviz.helperClasses.NameGenerator;
import piviz.helperClasses.RestrictionTable;


/**
 * Node representing the restriction pi-constructs. It holds a list of names
 * which are restricted to the following processes.
 * 
 * @author Anja
 * 
 */
public class ASTRestriction extends SimpleNode {
	private ArrayList resNames;

	public ASTRestriction(int id) {
		super(id);
		resNames = new ArrayList();
	}

	public ASTRestriction(PiParser p, int id) {
		super(p, id);
		resNames = new ArrayList();
	}

	public ArrayList getResNames() {
		return resNames;
	}

	public void addResName(String name) {
		resNames.add(name);
	}

	/**
	 * Dump this tree node in dot format. A dot node 'Restriction' is created
	 * with the restricted Names as a list.
	 */
	public int dumpDot(String prefix, int nodeCount, FileWriter fw) {
		// System.out.println(toString(prefix)+ nodeCount + ";");
		try {
			// "parentNodeName -> nodeName_Id;"
			fw.write(toString(prefix) + "_" + nodeCount + ";\n");
			// nodeName_Id [label = "*ch: channelName, *params: [a,b,c]"];
			fw.write(toString() + "_" + nodeCount + " [label = " + "\""
					+ toString() + "\\n*PID: " + getPid() + "\\n*params: "
					+ getResNames().toString() + "\\n*Process: "
					+ getProcessName() + "\"];\n ");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		int newCount = nodeCount;

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					newCount = n.dumpDot(toString() + "_" + nodeCount + " -> ",
							newCount + 1, fw);
				}
			}
		}
		return newCount;
	}

	/**
	 * Make a copy of this subtree. This includes creating a new restriction
	 * node and setting the resNames. A restriction node has exactly one child
	 * node or none (if inactive afterwards).
	 * 
	 * @return Pointer to the root of the new subtree.
	 */
	public SimpleNode copySubtree(String postFix) throws PiExecutionException {

		ASTRestriction cNode = new ASTRestriction(
				PiParserTreeConstants.JJTRESTRICTION);
		cNode.setResNames(new ArrayList(this.getResNames()));
		cNode.setProcessName(this.getProcessName()+postFix);
		if (children != null) {
			if (children.length > 1)
				throw new PiExecutionException(
						toString()
								+ ": copySubtree(): Unexpected number of child nodes encountered: "
								+ children.length);
			if (children.length == 1) {
				SimpleNode n = (SimpleNode) children[0];
				if (n != null) {
					cNode.jjtAddChild(n.copySubtree(postFix), 0);
				}
			}
		}
		return cNode;
	}

	public void setResNames(ArrayList resNames) {
		this.resNames = resNames;
	}

	/**
	 * Names in the resNames ArrayList should not be overwritten because they
	 * are bound, they will be renamed to unique other names instead. This
	 * triggers another renaming cycle for the child nodes before going on with
	 * the original one, because the bound names have to be renamed first.
	 */
	public void renameNames(ArrayList oldNames, ArrayList newNames) {
		/*
		 * rename each bound name which would be overwritten by newNames and
		 * start a renaming cycle for the subtree for the renamed names.
		 */

		ArrayList oldResNames = new ArrayList();
		ArrayList newResNames = new ArrayList();
		// look for the names which have to be renamed
		for (int i = 0; i < resNames.size(); i++) {
			// incoming name already exists bound
			if (newNames.contains(resNames.get(i))) {
				// generate new name
				String newName = NameGenerator
						.generateUniqueName((String) resNames.get(i));
				// rename this name in the subtree
				oldResNames.add(resNames.get(i));
				newResNames.add(newName);
				// rename the name in the resNames ArrayList
				resNames.set(i, newName);
			}
		}

		// do the renaming if some names where found
		if (!oldResNames.isEmpty()) {
			if (children.length == 1) {
				SimpleNode n = (SimpleNode) children[0];
				if (n != null) {
					n.renameNames(oldResNames, newResNames);
				}
			}
		}

		// forward command to children
		super.renameNames(oldNames, newNames);
	}

	/**
	 * Restrict the names in this node to the subtree - no execution if it is a
	 * descendent of a replication node.
	 */
	public void getAction(boolean blockExecution, SimpleNode defTreeRoot,
			Hashtable resultVector, SimpleNode parent, RestrictionTable resTable)
			throws PiExecutionException, RestrictionTableException {

		// set the parent of this node
		this.jjtSetParent(parent);

		// get action from the subtree
		if (children.length > 1)
			throw new PiExecutionException(
					toString()
							+ ": getAction(): Wrong number of child nodes encountered: "
							+ children.length);

		/*
		 * Go on looking for an executable action - a restriction node may only
		 * have one child.
		 */
		else if (children.length == 1) {

			// Not a descendent of a replication node
			if (!blockExecution) {
				/*
				 * Create a new unique name for each name in the resNames
				 * ArrayList and rename the names in the subtree
				 */
				ArrayList uniqueNames = new ArrayList();
				for (int i = 0; i < resNames.size(); i++) {
					String newName = NameGenerator
							.generateUniqueName((String) resNames.get(i));
					uniqueNames.add(i, newName);
				}
				SimpleNode n = (SimpleNode) children[0];
				if (n != null)
					n.renameNames(this.resNames, uniqueNames);

				/*
				 * Add entries to the restriction table the entry which is added
				 * holds the process ID of this subtree and the names mentioned
				 * in resNames, which have been replaced by new unique names
				 */
				ArrayList pid = new ArrayList();
				pid.add(this.getPid());

				resTable.addEntry(pid, uniqueNames, false);

				// replace the restriction node with its child node.
				parent.removeChild(this);
				parent.jjtAddChild(this.jjtGetChild(0), parent.jjtGetNumChildren());

			}
			/*
			 * Descendent of a replication node - no execution, but the entries
			 * in resNames have to be kept in mind to determine if the actions
			 * in the subtree are reachable from the outside.
			 */

			else {
				ArrayList p = new ArrayList();
				p.add(this.getPid());
				resTable.addEntry(p, new ArrayList(this.getResNames()), true);
				SimpleNode n = (SimpleNode) children[0];
				if (n != null)
					n.getAction(blockExecution, defTreeRoot, resultVector,
							this, resTable);
				// Check if the child has been replaced and redo the
				// getAction()
				// step.
				while (n != this.jjtGetChild(0)) {
					n = (SimpleNode) this.jjtGetChild(0);
					if (n != null)
						n.getAction(blockExecution, defTreeRoot, resultVector,
								this, resTable);
				}

			}
		}

		// remove this node if it does not have any children
		else if (children.length == 0)
			parent.removeChild(this);

	}

	/**
	 * Removes the temporal entry from the restriction table, creates new unique
	 * names and adds the new entry and renames the sub processes names.
	 */
	public void executeNode(SimpleNode node, RestrictionTable resTable)
			throws RestrictionTableException, PiExecutionException {

		// First go all the way up and execute the ancestors of this node.
		super.executeNode(node, resTable);

		// Now the parent should be the root node
		if (!this.parent.toString().equals("Root"))
			throw new PiExecutionException(toString()
					+ " executeNode(): Parent was expected to be Root.");

		/*
		 * Create a new unique name for each name in the resNames ArrayList and
		 * rename the names in the subtree
		 */
		ArrayList uniqueNames = new ArrayList();
		for (int i = 0; i < resNames.size(); i++) {
			String newName = NameGenerator.generateUniqueName((String) resNames
					.get(i));
			uniqueNames.add(i, newName);
		}
		SimpleNode n = (SimpleNode) children[0];
		if (n != null)
			n.renameNames(this.resNames, uniqueNames);

		/*
		 * Add entries to the restriction table, the entry which is added holds
		 * the process ID of this subtree and the names mentioned in resNames,
		 * which have been replaced by new unique names
		 */
		ArrayList pid = new ArrayList();
		pid.add(this.getPid());

		resTable.addEntry(pid, uniqueNames, false);

		// remove the temporal entry
		resTable.removeEntry(pid, resNames, true);

		// Add sub tree to exec tree
		if (this.jjtGetNumChildren() == 1) {
			n = (SimpleNode) children[0];
			if (n != null)
				parent.jjtAddChild(n, parent.jjtGetNumChildren());
		} else if (this.jjtGetNumChildren() > 1)
			throw new PiExecutionException(toString()
					+ " executeNode: Too many child nodes encountered.");

		// remove this tree
		((SimpleNode) this.parent).removeChild(this);

	}
	
	/**
	 * Go up and find all ancestor restriction nodes and add them to the list.
	 */
	public boolean isChildOfRestrictionNode(String channel){
		if (this.resNames.contains(channel))
			return true;
		else return super.isChildOfRestrictionNode(channel);
	}
	
	/**
	 * Get the process definition of this node and its subnodes and return it.
	 * 
	 * @return
	 */
	public String getProcessDefinitions() {
		String str = "(^";
		String params = resNames.toString();
		params = params.substring(1,params.length()-1);
		str = str + params + ")";

		if (this.jjtGetNumChildren() > 0) {
			SimpleNode n = (SimpleNode) this.jjtGetChild(0);
			if (n != null) {
				str = str + " " + n.getProcessDefinitions();
			}
		}
		else
			str = str + ".0";
		return str;
	}
}
