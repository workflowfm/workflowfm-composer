/* Generated By:JJTree: Do not edit this line. ASTMatch.java */

package piviz.executionEngine;


import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;

import piviz.exceptions.PiExecutionException;
import piviz.helperClasses.RestrictionTable;


/**
 * Node representing the match pi-construct. It holds two names which are going
 * to be compared when the match node is executed.
 * 
 * @author Anja
 * 
 */
public class ASTMatch extends SimpleNode {

	public static final int EQUAL = 0;

	public static final int UNEQUAL = 1;

	private String name1, name2;

	private int kind;

	public void setKind(int k) {
		this.kind = k;
	}

	public String getName1() {
		return name1;
	}

	public void setName1(String name1) {
		this.name1 = name1;
	}

	public String getName2() {
		return name2;
	}

	public void setName2(String name2) {
		this.name2 = name2;
	}

	public ASTMatch(int id) {
		super(id);
	}

	public ASTMatch(PiParser p, int id) {
		super(p, id);
	}

	/**
	 * Dump this tree node in dot format. A dot node 'Match' is created with the
	 * attributes name1 and name2 that are going to be compared.
	 */
	public int dumpDot(String prefix, int nodeCount, FileWriter fw) {
		// System.out.println(toString(prefix)+ nodeCount + ";");
		try {
			// "parentNodeName -> nodeName_Id;"
			fw.write(toString(prefix) + "_" + nodeCount + ";\n");
			// nodeName_Id [label = "*ch: channelName, *params: [a,b,c]"];
			fw.write(toString() + "_" + nodeCount + " [label = " + "\""
					+ toString() + "\\n*PID: " + getPid() + "\\n*kind: "
					+ getKindString() + "\\n*name1: " + getName1()
					+ "\\n*name2: " + getName2() + "\\n*Process: "
					+ getProcessName() + "\"];\n ");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		int newCount = nodeCount;

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					newCount = n.dumpDot(toString() + "_" + nodeCount + " -> ",
							newCount + 1, fw);
				}
			}
		}
		return newCount;
	}

	/**
	 * Make a copy of this subtree. This includes creating a new Match node,
	 * setting the attributes name1 and name2. A Match node has exactly one
	 * child node.
	 * 
	 * @return Pointer to the root of the new subtree.
	 */
	public SimpleNode copySubtree(String postFix) throws PiExecutionException {

		ASTMatch cNode = new ASTMatch(PiParserTreeConstants.JJTMATCH);
		cNode.setName1(this.getName1());
		cNode.setName2(this.getName2());
		cNode.setKind(this.kind);
		cNode.setProcessName(this.getProcessName() + postFix);
		if (children != null) {
			if (children.length != 1)
				throw new PiExecutionException(
						toString()
								+ ": copySubtree(): Unexpected number of children encountered: "
								+ children.length);
			SimpleNode n = (SimpleNode) children[0];
			if (n != null) {
				cNode.jjtAddChild(n.copySubtree(postFix), 0);
			}
		}
		return cNode;
	}

	public void renameNames(ArrayList oldNames, ArrayList newNames) {
		// replace the names if the have changed
		if (oldNames.contains(name1))
			name1 = (String) newNames.get(oldNames.indexOf(name1));
		if (oldNames.contains(name2))
			name2 = (String) newNames.get(oldNames.indexOf(name2));
		// forward command to children
		super.renameNames(oldNames, newNames);

	}

	/**
	 * Execute match node: replace it with its child node in case name1 matches
	 * name2 and remove the whole subtree in case the two names do not match.
	 */
public void getAction(boolean blockExecution,
			SimpleNode defTreeRoot, Hashtable resultVector, SimpleNode parent,
			RestrictionTable resTable) throws PiExecutionException {
		// set parent node
		this.jjtSetParent(parent);

		/*
		 * BlockExecution does not make any sense here if for example we have a
		 * definition like: a.![x=y]s.0 and the action a has been done, the
		 * match can be resolved without disturbing the replication.
		 */

		parent.removeChild(this);
		if ((kind == ASTMatch.EQUAL && name1.compareTo(name2) == 0)
				|| (kind == ASTMatch.UNEQUAL && name1.compareTo(name2) != 0)) 
			parent.jjtAddChild(this.jjtGetChild(0), parent.jjtGetNumChildren());
		
	}
	/**
	 * Get the process definition of this node and its subnodes and return it.
	 * 
	 * @return
	 */
	public String getProcessDefinitions() {
		String str = "[" + name1 + " = " + name2 + "]";

		SimpleNode n = (SimpleNode) this.jjtGetChild(0);
		if (n != null) {
			str = str + n.getProcessDefinitions();
		}
		return str;
	}

	private String getKindString() {
		if (this.kind == ASTMatch.EQUAL)
			return "Equal";
		else if (this.kind == ASTMatch.UNEQUAL)
			return "Unequal";
		else
			return "Unknown";

	}

}
