/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package piviz.executionEngine;


import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;

import piviz.exceptions.PiExecutionException;
import piviz.exceptions.RestrictionTableException;
import piviz.helperClasses.RestrictionTable;


/**
 * The simple node is the base class for the AST Nodes. Attributes and accessors
 * to these which all the other AST Nodes have in common are implemented here.
 * These are the process id (pid) which is needed during execution for scoping
 * and the process name (pname) which is needed for the visualization.
 * 
 * @author Anja
 * 
 */
public class SimpleNode implements Node {
	protected Node parent;

	protected Node[] children;

	protected int id;

	protected PiParser parser;

	private String pid;

	private String processName;

	/**
	 * A process during execution can be uniquely identified by its process
	 * identifier pid. During execution the pid of a process changes, for
	 * example if the process splits into concurrent execution. Visualization
	 * though still needs to find out which process has changed and therefore
	 * needs the old pid.
	 */
	// private String oldPID;
	/**
	 * Recursion without recursion ending creates an endless loop. This can be
	 * detected by this field. An example would be the process A()=B()|C() with
	 * B()=b.0|A() and C()='b.0|A(). Agent A() would be resolved endless times.
	 * Constructs like A() = ...A() with no pi-Action before the resolvation of
	 * A() will be forbidden.
	 */
	private ArrayList endlessAgentLoopDetector;

	public ArrayList getEndlessAgentLoopDetector() {
		return this.endlessAgentLoopDetector;
	}

	/**
	 * Adds agent names to the detector.
	 * 
	 * @param agentNames
	 *            Names to be added.
	 */
	public void updateEndlessAgentLoopsDetector(ArrayList agentNames) {
		this.endlessAgentLoopDetector.clear();
		this.endlessAgentLoopDetector.addAll(agentNames);
		// also call this method for all nodes in the subtree
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.updateEndlessAgentLoopsDetector(agentNames);
				}
			}
		}

	}

	/**
	 * Delete the entries in this endlessAgentLoopDetector ArrayList, this will
	 * happen when a pi-Action is encountered, so we do not have paths like A()
	 * ... B() ... A() with no pi inbetween, which will cause endless loops.
	 * 
	 */
	public void clearEndlessAgentLoopsDetector() {
		this.endlessAgentLoopDetector.clear();
		// also call this method for all nodes in the subtree
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.clearEndlessAgentLoopsDetector();
				}
			}
		}

	}

	public String getPid() {
		return pid;
	}

	public void setPid(String pid) {
		// remember the old process id if it is not empty
		// if (!this.pid.equals(""))
		// this.oldPID = this.pid;
		// else
		// this.oldPID = pid;
		this.pid = pid;
		// also call this method for all nodes in the subtree
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.setPid(pid);
				}
			}
		}

	}

	public SimpleNode(int i) {
		id = i;
		pid = "";
		processName = "";
		endlessAgentLoopDetector = new ArrayList();
	}

	public SimpleNode(PiParser p, int i) {
		this(i);
		parser = p;
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}

	public void jjtSetParent(Node n) {
		parent = n;
	}

	public Node jjtGetParent() {
		return parent;
	}

	/**
	 * Replaces the child node at the given position. (Naming convention from
	 * parser generator.)
	 */
	public void jjtAddChild(Node n, int i) {
		if (i < 0)
			try {
				throw new PiExecutionException(toString()
						+ ": jjtAddChild(): Invalid position to add a child: "
						+ i);
			} catch (PiExecutionException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
		n.jjtSetParent(this);
	}

	/**
	 * Moves the child which is on this position and all behind it one position
	 * back and inserts the given node at the given position.
	 * 
	 * @param n
	 * @param position
	 */
	public void insertChild(Node n, int position) throws PiExecutionException {
		if (position < 0)
			throw new PiExecutionException(toString()
					+ ": insertChild(): Invalid position to insert a child: "
					+ position);
		if (children == null)
			jjtAddChild(n, 0);
		else if (position < children.length) {
			// Make space for this child, which means moving all the other
			// nodes from this position one position further back.
			Node c[] = new Node[children.length + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			for (int i = children.length; i > position; i--) {
				c[i] = c[i - 1];
			}
			c[position] = n;
			children = c;
			n.jjtSetParent(this);
		} else if (position >= children.length)
			jjtAddChild(n, position);

	}

	/**
	 * Remove the child at the given index.
	 * 
	 * @param index
	 */
	public void removeChild(int index) {
		if (children == null || index >= children.length)
			return;
		Node c[] = new Node[children.length - 1];
		int oldArrayIndex = 0;
		for (int i = 0; i < c.length; i++) {
			// skip the child, which will be removed
			if (oldArrayIndex == index)
				oldArrayIndex++;

			// copy to new array
			c[i] = children[oldArrayIndex];
			oldArrayIndex++;
		}
		children = c;
	}

	/**
	 * Removes the child
	 */
	public void removeChild(SimpleNode n) {
		if (children == null)
			return;
		// find the index of the child
		// boolean found = false;
		// int index;
		// for (index = 0; index < children.length; index++) {
		// if (children[index] == n) {
		// found = true;
		// break;
		// }
		// }
		int index = this.getPositionOfChild(n);
		if (index > -1)
			this.removeChild(index);
	}

	/**
	 * Get the position of this child.
	 * 
	 * @param n
	 * @return Position of child or -1 if not found.
	 */
	public int getPositionOfChild(SimpleNode n) {
		if (children == null)
			return -1;
		else {
			for (int index = 0; index < children.length; index++) {
				if (children[index] == n)
					return index;

			}
		}
		return -1;
	}

	public Node jjtGetChild(int i) {
		if (i >= children.length)
			return null;
		else
			return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	/*
	 * You can override these two methods in subclasses of SimpleNode to
	 * customize the way the node appears when the tree is dumped. If your
	 * output uses more than one line you should override toString(String),
	 * otherwise overriding toString() is probably all you need to do.
	 */

	public String toString() {
		return PiParserTreeConstants.jjtNodeName[id];
	}

	public String toString(String prefix) {
		return prefix + toString();
	}

	/*
	 * Override this method if you want to customize how the node dumps out its
	 * children.
	 */
	/**
	 * Dump this tree node in graphViz dot format.
	 */
	public int dumpDot(String prefix, int nodeCount, FileWriter fw) {
		// System.out.println(toString(prefix)+ nodeCount + ";");
		try {
			fw.write(toString(prefix) + "_" + nodeCount + ";\n");
			fw.write(toString() + "_" + nodeCount + " [label = \"" + toString()
					+ "\\n*PID: " + getPid() + "\\n*Process: "
					+ getProcessName() + "\"];\n ");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		int newCount = nodeCount;

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					newCount = n.dumpDot(toString() + "_" + nodeCount + " -> ",
							newCount + 1, fw);
				}
			}
		}
		return newCount;
	}

	public String getProcessName() {
		return processName;
	}

	public void setProcessName(String _processName) {
		this.processName = _processName;
		// also call this method for all nodes in the subtree
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.setProcessName(_processName);
				}
			}
		}
	}

	/**
	 * Determines the next executable action(s) in this subtree. All nodes on
	 * the way which can be executed instantly (except tau nodes - this is
	 * chosen by the user) will be executed. This includes defined agent,
	 * restriction, match and composition nodes.
	 * 
	 * Replication is a special case which has to be taken care of. Here
	 * execution of all sub nodes has to be postponed until this subtree is
	 * activated by the user for execution.
	 * 
	 * @param childIndex
	 *            If resolving takes place the new node replaces the old one.
	 *            The childIndex is needed to figure out which child node is
	 *            going to be replaced.
	 * 
	 * @param resultVector
	 *            Pointer to Hashtable where all available actions in this
	 *            subtree are to be added. The actions are added to entries with
	 *            the key of their channel, tau nodes are added to an extra
	 *            entry with the key "0-tau-0".
	 * 
	 * @param id
	 *            Is needed in case this child is executed instantly and is
	 *            replaced by the node which results.
	 * @param blockExecution
	 *            If "true" execution of all nodes which would be available for
	 *            execution instantly is blocked. This may be the case if an
	 *            ancestor is a replication node. Here just the available
	 *            actions are returned. It is important if there is a
	 *            restriction node in this definition, which will be executed
	 *            and then lost for the other spawned processes.
	 * @param defTreeRoot
	 *            In case defined agents have to be resolved, their definition
	 *            is needed, which can be found in the definition tree.
	 * @param resTable
	 *            Reference to restriction table which is held up to date during
	 *            this operation
	 */
	public void getAction(boolean blockExecution, SimpleNode defTreeRoot,
			Hashtable resultVector, SimpleNode parent, RestrictionTable resTable)
			throws PiExecutionException, RestrictionTableException {

		// set parent node
		this.jjtSetParent(parent);

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.getAction(blockExecution, defTreeRoot, resultVector,
							this, resTable);
					/*
					 * getAction could have removed the child node n, this has
					 * to be checked and in case of removal the index has to be
					 * adjusted, so every child is handled.
					 */
					if (children[i] != n)
						i--;
				}
			}
		}

	}

	/**
	 * Go through the subtree of this node and collect all further send and
	 * receive actions. Nothing will be executed here, only temporal entries may
	 * be created for the restriction table.
	 * 
	 * @param resultArray
	 *            Contains all blocked send and receive nodes.
	 * @param resTable
	 *            Reference to the restriction table for adding temporal
	 *            entries.
	 */
	public void getBlockedActions(Hashtable resultTable,
			RestrictionTable resTable) throws RestrictionTableException {

		/*
		 * Add this node to the resultArray if it is a send or receive action,
		 * except the used channel name is a bound name
		 */
		if (this.toString().equals("Send") || this.toString().equals("Receive")) {
			String chan = "";
			if (this.toString().equals("Send"))
				chan = ((ASTSend) this).getChannelName();
			else
				chan = ((ASTReceive) this).getChannelName();

			// check if chan is bound
			// if (!((SimpleNode) this.parent).isBoundName(chan)) {
			if (resultTable.containsKey(chan)) {
				ArrayList a = (ArrayList) resultTable.get(chan);
				a.add(this);
			} else {
				ArrayList a = new ArrayList();
				a.add(this);
				resultTable.put(chan, a);
			}
			// }
		}

		/*
		 * Add a temporal entry for the names if this is a restriction node.
		 * This keeps the following actions which are restricted to be seen from
		 * the outside.
		 */
		else if (this.toString().equals("Restriction")) {
			ArrayList p = new ArrayList();
			p.add(this.getPid());
			resTable.addEntry(p, new ArrayList(((ASTRestriction) this)
					.getResNames()), true);
		}

		// Get the actions of this nodes children.
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.getBlockedActions(resultTable, resTable);
				}
			}
		}
	}

	/**
	 * Return the node binding the channelName. It will be a receive node, with
	 * channelName as one of its parameters.
	 * 
	 * @param channelName
	 * @return
	 */
	public SimpleNode getBindingNode(String channelName) {
		if (this.toString().equals("Receive")) {
			if (((ASTReceive) this).getParameters().contains(channelName))
				return this;
		}
		if (this.toString().equals("Root"))
			return null;
		else if (!this.parent.toString().equals("Root"))
			return ((SimpleNode) this.parent).getBindingNode(channelName);
		else
			return null;
	}

	/**
	 * Check if channelName is bound.
	 * 
	 * @param channelName
	 * @return
	 */
	public boolean isBoundName(String channelName) {
		if (this.toString().equals("Receive")) {
			if (((ASTReceive) this).getParameters().contains(channelName))
				return true;
		}
		if (this.toString().equals("Root"))
			return false;
		else if (!this.parent.toString().equals("Root"))
			return ((SimpleNode) this.parent).isBoundName(channelName);
		else
			return false;
	}

	/**
	 * Make a copy of this subtree. Nodes which do not overwrite this method are
	 * AgentDefinition and Root nodes - these should not be encountered in the
	 * execution tree and within agent definitions.
	 * 
	 * @param postFix
	 *            TODO
	 * 
	 * @return Pointer to the root of the new subtree.
	 */
	public SimpleNode copySubtree(String postFix) throws PiExecutionException {
		return null;
	}

	/**
	 * Renaming takes place if a defined agent is resolved and if new names are
	 * received via a channel, then a (sub) set of the free names is renamed.
	 * Renaming walks through the whole subtree. Composition, Summation,
	 * Replication and Tau nodes do not need a special implementations since
	 * they do not hold any names. AgentDefinition and Root nodes should not be
	 * encountered within the execution tree.
	 * 
	 * @param oldNames
	 *            Names which are to be replaced.
	 * @param newNames
	 *            Names which replace the old ones.
	 */
	public void renameNames(ArrayList oldNames, ArrayList newNames) {
		// no special action taken just forward the request to the children
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.renameNames(oldNames, newNames);
				}
			}
		}

	}

	/**
	 * Execution of the node - this method should be reimplemented in
	 * Composition, Receive, Replication, Restriction, Send, Summation and Tau.
	 * All other nodes should not be encountered on the execution path, because
	 * they have been pre executed. Execution path means the path from the root
	 * node to the node to be executed. The nodes to be executed need to be kept
	 * in mind to be able to eliminate choices.
	 * 
	 * @param node
	 *            Node which is executed.
	 * 
	 */
	public void executeNode(SimpleNode node, RestrictionTable resTable)
			throws PiExecutionException, RestrictionTableException {
		// go up all the way to the root node of the execution tree and start
		// execution of
		// the path from its first node.
		SimpleNode n = (SimpleNode) this.jjtGetParent();
		if (n != null) {
			if (!this.jjtGetParent().toString().equals("Root")) {
				n.executeNode(node, resTable);
			}
		}
	}

	/**
	 * If a summation is resolved during execution the one subprocess which will
	 * be executed has to be found.
	 * 
	 * @param node
	 *            This node should be somewhere on the execution path.
	 * @return True if this is the path which has node on it.
	 */
	public boolean isOnExecutionPath(SimpleNode node) {
		if (this == node)
			return true;
		// go check the children of this node
		else if (this.jjtGetNumChildren() == 0)
			return false;
		else {
			for (int i = 0; i < this.jjtGetNumChildren(); i++) {
				SimpleNode child = (SimpleNode) this.children[i];
				if (child != null) {
					if (child.isOnExecutionPath(node))
						return true;
				}
			}
			return false;
		}
	}

	/**
	 * Go up and find summation nodes, which are the ancestors of this node.
	 * 
	 * @param sumNodes
	 *            Contains all the summation nodes found on the ancestor trail.
	 */
	public void getAncestorSummationNodes(ArrayList sumNodes) {
		if (!this.parent.toString().equals("Root"))
			((SimpleNode) this.parent).getAncestorSummationNodes(sumNodes);
	}

	/**
	 * Go up and find composition nodes, which are the ancestors of this node.
	 * 
	 * @param sumNodes
	 *            Contains all the summation nodes found on the ancestor trail.
	 */
	public void getAncestorCompositionNodes(ArrayList compNodes) {
		if (!this.parent.toString().equals("Root"))
			((SimpleNode) this.parent).getAncestorCompositionNodes(compNodes);
	}

	/**
	 * Go up and count how many nodes are between the root and this node.
	 * 
	 * @return
	 */
	int getDistanceFromRoot() {
		if (!this.parent.toString().equals("Root"))
			return ((SimpleNode) this.parent).getDistanceFromRoot() + 1;
		else
			return 1;
	}

	/**
	 * Go up and see if the node is a child of the restriction node restricting
	 * the channel.
	 * 
	 * @param resNodes
	 */
	public boolean isChildOfRestrictionNode(String channel) {
		if (!this.parent.toString().equals("Root"))
			return ((SimpleNode) this.parent).isChildOfRestrictionNode(channel);
		else
			return false;
	}

	/**
	 * Checks if this node is a descendent of a replication node.
	 * 
	 * @return True if parent is a replication node, false if parent is the root
	 *         (means that there are no more ancestors to check), else go
	 *         further up and check.
	 */
	public boolean isDescendentOfReplication() {
		if (this.parent.toString().equals("Replication"))
			return true;
		else if (this.parent.toString().equals("Root"))
			return false;
		else
			return ((SimpleNode) this.parent).isDescendentOfReplication();
	}

	/**
	 * Get the topmost ancestor replication node of this node.
	 * 
	 * @return Replication node if one exists.
	 */
	public ASTReplication getTopMostReplicationNode(ASTReplication foundRep) {
		// // see if this is a replication node
		// ASTReplication repNode = null;
		// ASTReplication upperRepNode = null;
		// if (this.toString().equals("Replication"))
		// repNode = (ASTReplication) this;
		// // go further up if possible and see if there are more replication
		// // nodes.
		// if (this.parent.toString() != "Root")
		// upperRepNode = ((SimpleNode) this.parent)
		// .getTopMostReplicationNode();
		//
		// if (upperRepNode != null)
		// return upperRepNode;
		// else
		// return repNode;
		ASTReplication upper = null;
		if (this.toString().equals("Replication"))
			foundRep = (ASTReplication) this;
		if (!this.parent.toString().equals("Root"))
			upper = ((SimpleNode) this.parent)
					.getTopMostReplicationNode(foundRep);

		if (upper != null)
			return upper;
		else
			return foundRep;
	}

	/**
	 * Process names are adjusted when a defined agent is resolved therefore it
	 * might happen, that different process names exist in a subtree going from
	 * top to bottom, but the one that is actually used should be the topmost
	 * one.
	 * 
	 * @return
	 */
	public String getProcessNameAtRoot() {
		if (this.parent.toString().equals("Root"))
			return this.getProcessName();
		else
			return ((SimpleNode) this.parent).getProcessNameAtRoot();
	}

	/**
	 * Get the process definition of this node and its subnodes and return it.
	 * 
	 * @return
	 */
	public String getProcessDefinitions() {

		return "";
	}

}
