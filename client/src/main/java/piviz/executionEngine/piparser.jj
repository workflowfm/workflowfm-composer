/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\piparser.jj */
/*@egen*//*
 * Pi Parser
 *
 */

options{
	LOOKAHEAD = 3;               
	STATIC = false;
}

PARSER_BEGIN(PiParser)
package executionEngine;
import java.io.InputStream;
import exceptions.PiParserError;
import java.util.HashSet;
import java.util.Hashtable;
import java.io.Reader;

/**
* PiParser uses an input stream and constructs an Abstract syntax tree from the definitions in
* this stream.
* @author Anja
*/
public class PiParser/*@bgen(jjtree)*/implements PiParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTPiParserState jjtree = new JJTPiParserState();

/*@egen*/

	/**
	* For checking if an agent is defined twice.
	*/
	private static HashSet agentNames;
	/**
	* Store information about the defined pools. The user does not have to define any pools.
	* They are just used for additional information during visualization.
	* pools looks like the following: <key: agentName><value:poolName>
	*/
	private static Hashtable pools;
	/**
	* For checking if a pool is defined twice.
	*/
	private static HashSet poolNames;
	
	private static String currentAgent;
	
	/**
	* Parse input stream and construct an Abstract Syntax Tree.
	* @return Returns the root node of the constructed tree.
	*/
	public static SimpleNode parseFile(InputStream stream) throws PiParserError, Exception {
		PiParser t = new PiParser(stream);
		if (agentNames == null) agentNames = new HashSet();
		else agentNames.clear();
		if (pools == null) pools = new Hashtable();
		else pools.clear();
		if (poolNames == null) poolNames = new HashSet();
		else poolNames.clear();
		currentAgent = "";
		SimpleNode n = null;
		//try {
	      n = t.Root();
	    /*} catch (Exception e) {
	      System.out.println("Oops.");
	      System.out.println(e.getMessage());
	      e.printStackTrace();
    	}*/
    	return n;
	}
	
	/**
	* Parse additional agent. Return root node with the new agent as children.
	*/
	public static SimpleNode parseAdditionalAgents(Reader stream, HashSet _agentNames, Hashtable _pools, HashSet _poolNames) throws PiParserError, Exception {
		PiParser t = new PiParser(stream);
		agentNames = _agentNames;
		pools = _pools;
		poolNames = _poolNames;
		currentAgent = "";
		SimpleNode n = null;
		//try {
	      n = t.Root();
	    /*} catch (Exception e) {
	      System.out.println("Oops.");
	      System.out.println(e.getMessage());
	      e.printStackTrace();
    	}*/
    	return n;
	}
	
	public static Hashtable getPoolTable(){
		return pools;
	}
	
	public static HashSet getPoolNames(){
		return poolNames;
	}
	
	public static HashSet getAgentNames(){
		return agentNames;
	}
}
PARSER_END(PiParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : { <INACTION: "0">}
TOKEN : { <AGENT_ID: (["A"-"Z"])+ ("_" | ["0"-"9"] | ["a"-"z"]|["A"-"Z"])*  >}
TOKEN : { <AGENT_TOK: "agent">}
TOKEN : { <TAU : "t" >}
TOKEN : { <EXEC : "exec">}
TOKEN : { <POOL_TOK: "pool">}
TOKEN : { <CHAN_ID:  ("_" | ["0"-"9"] | ["a"-"z"]) ("_" | ["0"-"9"] | ["a"-"z"]|["A"-"Z"])*>}




/**
* Create the root node.
*/
SimpleNode Root() : {/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Root */
  try {
/*@egen*/
  Expression() <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* No node is created for this rule but it takes care that at least one agent is defined.
*/
void Expression()      : {}{
	(PoolDefinition())*
	(AgentDefinition())+ 
}
/**
* Get the definitions of the pools and store them in the pool table.
*
*/
void PoolDefinition()      :{Token agentName, poolName;}{
	<POOL_TOK>
	poolName = <AGENT_ID>
	{	// Check if the pool is defined twice
		if (poolNames.contains(poolName.image))
			throw new PiParserError("Encountered duplicate pool definition: "+ poolName.image);
	}
	
	"{" 
		agentName = <AGENT_ID> 
		{	// Check if the agent already belongs to another pool
			if ( pools.containsKey(agentName.image))
				throw new PiParserError("Agent "+ agentName.image + " already belongs to another pool.");
			pools.put(agentName.image, poolName.image);
		}
		("," agentName = <AGENT_ID>
			{	// Check if the agent already belongs to another pool
				if ( pools.containsKey(agentName.image))
					throw new PiParserError("Agent "+ agentName.image + " already belongs to another pool.");
				pools.put(agentName.image, poolName.image);
			}			
		)*		
	"}"
}

/**
* Create an agentDefinition node and set its attributes, which are the name of the agent (agentName),
* the parameters and if this agent is going to be executed right away  (setExecuteAgent).
*
* The definition of an agent has the following syntax:
* "exec"? "agent" <AgentName> "(" parameters ") = " <ProcessDefintion> 
*/
void AgentDefinition() : {/*@bgen(jjtree) AgentDefinition */
                          ASTAgentDefinition jjtn000 = new ASTAgentDefinition(JJTAGENTDEFINITION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token name;}{/*@bgen(jjtree) AgentDefinition */
        try {
/*@egen*/
	(<EXEC> {	jjtn000.setExecuteAgent(true);	})? 
	<AGENT_TOK> 
	name = <AGENT_ID> 
	{	
		currentAgent = name.image;
		// check if this agent already exists
		if (agentNames.contains(name.image)){
			throw new PiParserError("Encountered duplicate definition of agent: " + name.image);
		}
		else agentNames.add(name.image);
	
		jjtn000.setAgentName(name.image);	
	}
	(	"()"|"("")" |
		("("
			name = <CHAN_ID>
			{	jjtn000.addParameter(name.image);	}
			("," 
				name = <CHAN_ID>
				{	jjtn000.addParameter(name.image);	}
			)*
	 	")" )
	 )
		
	"=" Composition()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* A composition node is created if there is more than one process definition specified seperated by
* the "|"-operator.
*/
void Composition()      : {}{/*@bgen(jjtree) #Composition(> 1) */
        {
          ASTComposition jjtn001 = new ASTComposition(JJTCOMPOSITION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		P() ("|" P())*	
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

/**
* No "P" node is created, it makes sure that the process definition can consist of the constructs
* restriction, replication, defined agents and summation.
*/
void P()      : {}{
	Restriction() (Composition())?
	| Replication() (Composition())?
	| DefinedAgent()
	| Summation()
	| "(" Composition() ")"
	
}

/**
* Create a summation node if more than one choices are available seperated by the "+" operator.
*/
void Summation()      : {}{/*@bgen(jjtree) #Summation(> 1) */
        {
          ASTSummation jjtn001 = new ASTSummation(JJTSUMMATION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		M() ("+" M())*
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

/**
* No "M" node is created. This rule makes sure that choices are either inactive or start with one
* of the constructs defined by Pi().
*/
void M()      : {}{
	<INACTION> | Pi()
}

/**
* Create a restriction node and fill its parameter vector.
*/
void Restriction() : {/*@bgen(jjtree) Restriction */
                      ASTRestriction jjtn000 = new ASTRestriction(JJTRESTRICTION);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token name;}{/*@bgen(jjtree) Restriction */
        try {
/*@egen*/
	(
		"^" ( name = <CHAN_ID> {	jjtn000.addResName(name.image);	}
			("," name = <CHAN_ID> {	jjtn000.addResName(name.image);	} )*) 
		
		| "(" "^" (name = <CHAN_ID> {	jjtn000.addResName(name.image);	} 
			("," name = <CHAN_ID> {	jjtn000.addResName(name.image);	} )*) ")"
	)
	(
		//"(" Composition() ")"
		//| 
		P()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Create a replication node.
*/
void Replication() : {/*@bgen(jjtree) Replication */
  ASTReplication jjtn000 = new ASTReplication(JJTREPLICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Replication */
        try {
/*@egen*/
	"!" 
	(
		//"(" Composition() ")"
		//| 
		P()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Create a defined agent node and set its attributes agentName and parameters.
* A defined agent and the agent that turns into this defined agent have to be defined in
* the same pool.
*/
void DefinedAgent() : {/*@bgen(jjtree) DefinedAgent */
                       ASTDefinedAgent jjtn000 = new ASTDefinedAgent(JJTDEFINEDAGENT);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token name;}{/*@bgen(jjtree) DefinedAgent */
        try {
/*@egen*/
	name = <AGENT_ID>
	{	
		if (pools.get(currentAgent) != null){
			if (!pools.get(currentAgent).equals(pools.get(name.image)))
				throw new PiParserError("Agents "+currentAgent+" and "+name.image+" are not in the same pool.");
		}
		else if (pools.get(name.image) != null)
			throw new PiParserError("Agents "+currentAgent+" and "+name.image+" are not in the same pool.");
		
		jjtn000.setAgentName(name.image);	
	}
	
	("()"|"("")" | 
		(	"(" 
				name = <CHAN_ID>
				{	jjtn000.addParameter(name.image);	}
				("," 
					name = <CHAN_ID>
					{	jjtn000.addParameter(name.image);	}
				)*
				
			")"
		)
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
* No "Pi" node is created. This rule makes sure that the pi-constructs send, receive, tau and match
* can be used respectively.
*/
void Pi()      : {}{
	Send() | Receive() | Tau() | Match()
}

/**
* Create a send node and set its attributes channelName and parameters.
*/
void Send() : {/*@bgen(jjtree) Send */
                ASTSend jjtn000 = new ASTSend(JJTSEND);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/	Token channel;	}{/*@bgen(jjtree) Send */
        try {
/*@egen*/
	"'" channel = <CHAN_ID>  
	{	jjtn000.setChannelName(channel.image);	}
	("<>" | ( 
		"<" channel = <CHAN_ID> 
		{	jjtn000.addParameter(channel.image);	}
		(("," channel = <CHAN_ID>)
		{	jjtn000.addParameter(channel.image);	}
		)*
		">" 
	)? )
	Forward()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Create a receive node and set its attributes channelName and parameters.
*/
void Receive() : {/*@bgen(jjtree) Receive */
                  ASTReceive jjtn000 = new ASTReceive(JJTRECEIVE);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token channel;}{/*@bgen(jjtree) Receive */
        try {
/*@egen*/
	channel = <CHAN_ID> 
	{	jjtn000.setChannelName(channel.image);	}
	("()" | ( 
		"(" channel = <CHAN_ID> 
		{	jjtn000.addParameter(channel.image);	}
		(("," channel = <CHAN_ID>)
		{	jjtn000.addParameter(channel.image);	}
		)*
		")" 
	)?)	
	Forward()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Create a tau node.
*/
void Tau() : {/*@bgen(jjtree) Tau */
  ASTTau jjtn000 = new ASTTau(JJTTAU);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Tau */
        try {
/*@egen*/
	<TAU> Forward()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Create a match node and set its attributes name1 and name2 which refer to the channel names going
* to be compared.
*/
void Match() : {/*@bgen(jjtree) Match */
                ASTMatch jjtn000 = new ASTMatch(JJTMATCH);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token name;}{/*@bgen(jjtree) Match */
        try {
/*@egen*/
	"[" name = <CHAN_ID> {	jjtn000.setName1(name.image);	}
		(("=" {jjtn000.setKind(ASTMatch.EQUAL);})|("!="{jjtn000.setKind(ASTMatch.UNEQUAL);})) 
		name = <CHAN_ID> {	jjtn000.setName2(name.image);	} "]" Pi()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* No "Forward" node is created - workaround for left recursion.
*/
void Forward()       : {}{
	"." (	Restriction() (Composition())?
			| Replication() (Composition())?
			| DefinedAgent()
			| "(" Composition() ")"
			| M())
}