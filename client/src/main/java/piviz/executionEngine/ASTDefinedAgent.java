/* Generated By:JJTree: Do not edit this line. ASTDefinedAgent.java */

package piviz.executionEngine;


import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;

import piviz.exceptions.PiExecutionException;
import piviz.exceptions.RestrictionTableException;
import piviz.helperClasses.PidGenerator;
import piviz.helperClasses.RestrictionTable;
import piviz.helperClasses.RestrictionTableEntry;


/**
 * Tree node representing an already defined agent whose process definition is
 * going to replace this part of the tree. Its attributes are the name of the
 * agent and the agents parameter list holding all of the agents free names.
 * 
 * @author Anja
 * 
 */
public class ASTDefinedAgent extends SimpleNode {
	private String AgentName;

	private ArrayList parameters;

	public ASTDefinedAgent(int id) {
		super(id);
		parameters = new ArrayList();
	}

	public ASTDefinedAgent(PiParser p, int id) {
		super(p, id);
		parameters = new ArrayList();
	}

	public String getAgentName() {
		return AgentName;
	}

	public void setAgentName(String agentName) {
		AgentName = agentName;
	}

	public ArrayList getParameters() {
		return parameters;
	}

	public void addParameter(String param) {
		parameters.add(param);
	}

	/**
	 * Dump this tree node in dot format. A dot node 'AgentDefinition' is
	 * created with the attributes agentName and its parameters representing all
	 * of its free names.
	 */
	public int dumpDot(String prefix, int nodeCount, FileWriter fw) {
		// System.out.println(toString(prefix)+ nodeCount + ";");
		try {
			// "parentNodeName -> nodeName_Id;"
			fw.write(toString(prefix) + "_" + nodeCount + ";\n");
			// nodeName_Id [label = "*ch: channelName, *params: [a,b,c]"];
			fw.write(toString() + "_" + nodeCount + " [label = " + "\""
					+ toString() + "\\n*name: " + getAgentName() + "\\n*PID: "
					+ getPid() + "\\n*params: " + getParameters().toString()
					+ "\\n*Process: " + getProcessName() + "\"];\n ");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		int newCount = nodeCount;

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					newCount = n.dumpDot(toString() + "_" + nodeCount + " -> ",
							newCount + 1, fw);
				}
			}
		}
		return newCount;
	}

	/**
	 * 
	 * @param parameters
	 */
	public void setParameters(ArrayList parameters) {
		this.parameters = parameters;
	}

public void getAction(boolean blockExecution, SimpleNode defTreeRoot,
			Hashtable resultVector, SimpleNode parent, RestrictionTable resTable)
			throws PiExecutionException, RestrictionTableException {

		/*
		 * BlockExecution does not make any sense here if for example we have a
		 * definition like: ! A(x,y) we can resolve the agent, this is just for
		 * restriction so no new process is spawned.
		 */

		// set parent node
		this.jjtSetParent(parent);

		/*
		 * First check for endless agent resolving loops.
		 */
		if (this.getEndlessAgentLoopDetector().contains(
				(String) this.getAgentName()))
			throw new PiExecutionException(toString()
					+ " getAction(): Endless loop of agent "
					+ this.getAgentName() + " detected.");

		// get definition node for this agent
		ASTAgentDefinition adNode = ((ASTRoot) defTreeRoot)
				.getAgentDefinition(this.AgentName);
		if (adNode == null)
			throw new PiExecutionException(toString()
					+ ": getAction(): No agent definition with name '"
					+ this.getAgentName() + "' was found.");
		// see if they are compatible regarding number of parameters
		if (adNode.getParameters().size() != this.parameters.size())
			throw new PiExecutionException(toString()
					+ " : getAction(): Parameter lists have different length ("
					+ adNode.getAgentName() + ", " + this.AgentName + ")");
		/*
		 * now resolve agent - replace this node by the defined process for this
		 * agent an agent definitions has exactly one child node.
		 */
		SimpleNode replacementNode = (((SimpleNode) adNode.jjtGetChild(0)))
				.copySubtree("");
		//int position = parent.getPositionOfChild(this);
		((SimpleNode)this.parent).removeChild(this);
		parent.jjtAddChild(replacementNode, this.parent.jjtGetNumChildren());
		/*
		 * - replace the name placeholders old name list:
		 * adNode.getParameters(), new name list: this.getParemters() [TODO]:
		 * check the case old: (a,a,b) new: (f,g,h), which may lead to errors
		 */
		replacementNode.renameNames(adNode.getParameters(), this
				.getParameters());

		// set PIDs of subtree to the PID of this node
		replacementNode.setPid(this.getPid());
		/*
		 * If the resolved agent is direct child of root, check if there are any
		 * restricted names to this process, that are not part of the agents
		 * parameter list. In such a case the agents process should not have
		 * acces to these names any longer and therefore its pid is removed from
		 * the list.
		 */
		if (this.parent.toString().equals("Root")) {
			ArrayList entries = resTable.findEntriesForPid(this.getPid());
			if (entries != null){
				if (entries.size() > 0){
					for (int j = 0; j < entries.size();j++){
						RestrictionTableEntry entry = (RestrictionTableEntry) entries.get(j);
						if (entry != null){
							for(int i = 0; i < parameters.size(); i++){
								String param = (String) parameters.get(i);
								if (!entry.getNames().contains(param)){
									/*
									 * check that the entry does not contain any
									 * other names of this agent
									 */
									ArrayList pars = new ArrayList(parameters);
									pars.retainAll(entry.getNames());
									if (pars.size() == 0)
										entry.removePid(this.getPid());
								}
							}
						}
					}
				}
			}
			/*
			 * for (int i = 0; i > parameters.size(); i++) { String param =
			 * (String) parameters.get(i); RestrictionTableEntry entry =
			 * resTable.getEntryForPidAndName( this.getPid(), param); if (entry !=
			 * null) { // check if the entry contains more names of the agent
			 * than // this ArrayList pars = new ArrayList(parameters);
			 * pars.retainAll(entry.getNames()); if (pars.size() == 0) throw new
			 * PiExecutionException( "Internal error during resolving of defined
			 * agent: broken restriction table entry."); else if (pars.size() ==
			 * 1) entry.removePid(this.getPid()); else {
			 * 
			 * remove the name and the pid from the original entry and make a
			 * new entry containing the name and all other pids
			 * 
			 * entry.removeName(param); ArrayList pids = new
			 * ArrayList(entry.getPids()); pids.remove(this.getPid()); ArrayList
			 * names = new ArrayList(); names.add(param);
			 * resTable.addEntry(pids, names, false); } } }
			 */
		}

		/*
		 * set ProcessName to parents process name, if the parent is the exec
		 * root, then use the name given by the defined agent
		 */
		// replacementNode.setProcessName(adNode.getAgentName());
		replacementNode.setProcessName(adNode.getAgentName()
				+ PidGenerator.getIdFromName(this.getProcessName()));
		// also add the old nodes names and its own name to the
		// endlessAgentDetectorList
		replacementNode.getEndlessAgentLoopDetector().add(
				(String) this.getAgentName());
		replacementNode.getEndlessAgentLoopDetector().addAll(
				this.getEndlessAgentLoopDetector());
		// TODO do this nicer!!!
		replacementNode.updateEndlessAgentLoopsDetector(new ArrayList(
				replacementNode.getEndlessAgentLoopDetector()));

	}	/**
		 * Make a copy of this subtree. This includes creating a new
		 * Defined_Agent node, setting the attributes agentName and parameters.
		 * A defined agent node does not have any children.
		 * 
		 * @return Pointer to the root of the new subtree.
		 */
	public SimpleNode copySubtree(String postFix) throws PiExecutionException {

		ASTDefinedAgent cNode = new ASTDefinedAgent(
				PiParserTreeConstants.JJTDEFINEDAGENT);
		cNode.setAgentName(this.getAgentName());
		cNode.setParameters(new ArrayList(this.getParameters()));
		cNode.setProcessName(this.getProcessName() + postFix);
		// Defined_Agent should not have any children
		if (children != null)
			throw new PiExecutionException(
					"Defined_Agent: copySubtree(): Children of defined agent "
							+ this.getAgentName() + " encountered.");
		return cNode;
	}

	/**
	 * Just rename as described in the SimpleNode documentation - no special
	 * cases.
	 */
	public void renameNames(ArrayList oldNames, ArrayList newNames) {
		// replace names in the parameter vector, that have changed
		for (int i = 0; i < parameters.size(); i++) {
			if (oldNames.contains(parameters.get(i)))
				parameters.set(i, newNames.get(oldNames.indexOf(parameters
						.get(i))));
		}
		// forward command to children
		super.renameNames(oldNames, newNames);

	}

	/**
	 * Get the process definition of this node and its subnodes and return it.
	 * 
	 * @return
	 */
	public String getProcessDefinitions() {
		String str = this.AgentName;
		String params = parameters.toString();
		// replace the "[" and "]" in params
		params = params.substring(1, params.length() - 1);
		str = str + "(" + params + ")";

		return str;
	}
}
