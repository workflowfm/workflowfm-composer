/* Generated By:JJTree: Do not edit this line. ASTTau.java */

package piviz.executionEngine;


import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;

import piviz.exceptions.PiExecutionException;
import piviz.exceptions.RestrictionTableException;
import piviz.helperClasses.RestrictionTable;


/**
 * Represents the pi-construct unobserveable action.
 * 
 * @author Anja
 * 
 */
public class ASTTau extends SimpleNode {
	public ASTTau(int id) {
		super(id);
	}

	public ASTTau(PiParser p, int id) {
		super(p, id);
	}

	/**
	 * Dump this tree node in dot format.
	 */
	public int dumpDot(String prefix, int nodeCount, FileWriter fw) {
		// System.out.println(toString(prefix)+ nodeCount + ";");
		try {
			// "parentNodeName -> nodeName_Id;"
			fw.write(toString(prefix) + "_" + nodeCount + ";\n");
			// nodeName_Id [label = "nodeName"];
			fw.write(toString() + "_" + nodeCount + " [label = \"" + toString()
					+ "\\n*PID: " + getPid() + "\\n*Process: "
					+ getProcessName() + "\"];\n ");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		int newCount = nodeCount;

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					newCount = n.dumpDot(toString() + "_" + nodeCount + " -> ",
							newCount + 1, fw);
				}
			}
		}
		return newCount;
	}

	/**
	 * Make a copy of this subtree. This includes creating a new tau node,
	 * setting the attributes channelName and parameters. A receive node may
	 * have exactly one or no child node (inaction afterwards).
	 * 
	 * @return Pointer to the root of the new subtree.
	 */
	public SimpleNode copySubtree(String postFix) throws PiExecutionException {

		ASTTau cNode = new ASTTau(PiParserTreeConstants.JJTTAU);
		cNode.setProcessName(this.getProcessName()+postFix);
		if (children != null) {
			if (children.length > 1)
				throw new PiExecutionException(toString()
						+ " : copySubtree(): More than one child encountered.");
			if (children.length == 1) {
				SimpleNode n = (SimpleNode) children[0];
				if (n != null) {
					cNode.jjtAddChild(n.copySubtree(postFix), 0);
				}
			}
		}
		return cNode;
	}

	/**
	 * Adds the tau action node to the result  and returns from this
	 * subtree.
	 */
	public void getAction(boolean blockExecution,
			SimpleNode defTreeRoot, Hashtable resultVector, SimpleNode parent,
			RestrictionTable resTable) throws PiExecutionException {
		// set parent node
		this.jjtSetParent(parent);
		// clear the endlessAgentLoopDetector, because of the pi-Action tau
		// no this
		// is no endless agent resolving loop.
		this.clearEndlessAgentLoopsDetector();

		if (resultVector.containsKey("0-tau-0")){
			ArrayList a = (ArrayList)resultVector.get("0-tau-0");
			a.add(this);
		}			
		else {
			ArrayList a = new ArrayList();
			a.add(this);
			resultVector.put("0-tau-0", a); 
		}
	}

	/**
	 * Execution of a tau node just replaces it with its child node.
	 */
	public void executeNode(SimpleNode sendTauNode, SimpleNode receiveNode,
			RestrictionTable resTable)throws PiExecutionException, RestrictionTableException{

			if (sendTauNode == null)
				throw new PiExecutionException(toString()
						+ " executeNode(): Communicating tau node is null.");

			// First go all the way up and execute the ancestors of this node.
			super.executeNode(sendTauNode, resTable);

			// Now the parent should be the root node
			if (!this.parent.toString().equals("Root"))
				throw new PiExecutionException(toString()
						+ " executeNode(): Parent was expected to be Root.");

			// Add the child sub tree to the exec node
			if (this.jjtGetNumChildren() == 1) {
				SimpleNode n = (SimpleNode) this.children[0];
				if (n != null){
					this.parent.jjtAddChild(n,
							((SimpleNode) this.parent).getPositionOfChild(this));
					//n.setProcessName(n.getProcessName() + "'");
				}
			}
			// Tau node should have at most one child node
			else if (this.jjtGetNumChildren() > 1)
				throw new PiExecutionException(toString()
						+ " executeNode(): To many child nodes encountered.");
			// Remove tau sub tree
			((SimpleNode) this.parent).removeChild(this);

			// TODO: remove
			System.out.println("Tau Node finished execution.");

		
	}
	
	/**
	 * Get the process definition of this node and its subnodes and return it.
	 * 
	 * @return
	 */
	public String getProcessDefinitions() {
		String str = "t";
		if (this.jjtGetNumChildren() > 0) {
			SimpleNode n = (SimpleNode) this.jjtGetChild(0);
			if (n != null) {
				str = str + "." + n.getProcessDefinitions();
			}
		}
		else
			str = str + ".0";
		return str;
	}

}
