/* Generated By:JJTree: Do not edit this line. ASTSend.java */

package piviz.executionEngine;


import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;

import piviz.exceptions.PiExecutionException;
import piviz.exceptions.RestrictionTableException;
import piviz.helperClasses.RestrictionTable;


/**
 * The ASTSend tree node represents the pi-construct of sending parameters over
 * a channel. Its attributes are the name of the channel and the parameters
 * which are sent.
 * 
 * @author Anja
 */
public class ASTSend extends SimpleNode {
	private String channelName;

	private ArrayList parameters;

	public ASTSend(int id) {
		super(id);
		parameters = new ArrayList();
	}

	/**
	 * Dump this tree node in dot format. A dot node 'Send' is created with the
	 * attributes channelName representing the channel over which is sent and
	 * parameters representing the parameters to be sent.
	 */
	public int dumpDot(String prefix, int nodeCount, FileWriter fw) {
		// System.out.println(toString(prefix)+ nodeCount + ";");
		try {
			// "parentNodeName -> nodeName_Id;"
			fw.write(toString(prefix) + "_" + nodeCount + ";\n");
			// nodeName_Id [label = "*ch: channelName, *params: [a,b,c]"];
			fw.write(toString() + "_" + nodeCount + " [label = " + "\""
					+ toString() + "\\n*PID: " + getPid() + "\\n*ch: "
					+ getChannelName() + "\\n*params: "
					+ getParameters().toString() + "\\n*Process: "
					+ getProcessName() + "\"];\n ");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		int newCount = nodeCount;

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					newCount = n.dumpDot(toString() + "_" + nodeCount + " -> ",
							newCount + 1, fw);
				}
			}
		}
		return newCount;
	}

	public ASTSend(PiParser p, int id) {
		super(p, id);
		parameters = new ArrayList();
	}

	public String getChannelName() {
		return channelName;
	}

	public void setChannelName(String channelName) {
		this.channelName = channelName;
	}

	public ArrayList getParameters() {
		return parameters;
	}

	public void addParameter(String param) {
		parameters.add(param);
	}

	/**
	 * Make a copy of this subtree. This includes creating a new send node,
	 * setting the attributes channelName and parameters. A receive node may
	 * have exactly one or no child node (inaction afterwards).
	 * 
	 * @return Pointer to the root of the new subtree.
	 */
	public SimpleNode copySubtree(String postFix) throws PiExecutionException {

		ASTSend cNode = new ASTSend(PiParserTreeConstants.JJTSEND);
		cNode.setChannelName(this.getChannelName());
		cNode.setParameters(new ArrayList(this.getParameters()));
		cNode.setProcessName(this.getProcessName()+postFix);
		if (children != null) {
			if (children.length > 1)
				throw new PiExecutionException(toString()
						+ " : copySubtree(): More than one child encountered.");
			if (children.length == 1) {
				SimpleNode n = (SimpleNode) children[0];
				if (n != null) {
					cNode.jjtAddChild(n.copySubtree(postFix), 0);
				}
			}
		}
		return cNode;
	}

	public void setParameters(ArrayList parameters) {
		this.parameters = parameters;
	}

	/**
	 * Rename channel name as well as names in the parameters ArrayList.
	 */
	public void renameNames(ArrayList oldNames, ArrayList newNames) {
		// replace the names of the channel if it has changed
		if (oldNames.contains(channelName))
			channelName = (String) newNames.get(oldNames.indexOf(channelName));

		// rename parameters
		for (int i = 0; i < parameters.size(); i++) {
			if (oldNames.contains(parameters.get(i))) {
				parameters.set(i, newNames.get(oldNames.indexOf(parameters
						.get(i))));
			}
		}

		// forward command to children
		super.renameNames(oldNames, newNames);
	}

	/**
	 * Adds the send action node to the result ArrayList and returns from this
	 * subtree.
	 */
	public void getAction(boolean blockExecution,
			SimpleNode defTreeRoot, Hashtable resultVector, SimpleNode parent,
			RestrictionTable resTable) throws PiExecutionException {
		// set parent node
		this.jjtSetParent(parent);

		// clear the endlessAgentLoopDetector, because of the pi-Action send no
		// this
		// is no endless agent resolving loop.
		this.clearEndlessAgentLoopsDetector();

		if (resultVector.containsKey(this.getChannelName())){
			ArrayList a = (ArrayList)resultVector.get(this.getChannelName());
			a.add(this);
		}
		else{
			ArrayList a = new ArrayList();
			a.add(this);
			resultVector.put(this.getChannelName(), a);
		}
	}

	/**
	 * Just remove the send node and add its sub tree to the exec tree.
	 */
	public void executeNode(SimpleNode node, RestrictionTable resTable)
			throws PiExecutionException, RestrictionTableException {

		if (node == null)
			throw new PiExecutionException(toString()
					+ " executeNode(): Send node of the communicating is null.");
		// First go all the way up and execute the ancestors of this node.
		super.executeNode(node, resTable);

		// Now the parent should be the root node
		if (!this.parent.toString().equals("Root"))
			throw new PiExecutionException(toString()
					+ " executeNode(): Parent was expected to be Root.");

		// Add sub tree to exec tree
		if (this.jjtGetNumChildren() == 1) {
			SimpleNode n = (SimpleNode) this.children[0];
			if (n != null) {
				this.parent.jjtAddChild(n, ((SimpleNode) this.parent).getPositionOfChild(this));
				// n.setProcessName(n.getProcessName() + "'");
			}

		} else if (this.jjtGetNumChildren() > 1)
			throw new PiExecutionException(toString()
					+ " executeNode: Too many child nodes encountered.");

		// remove this tree
		((SimpleNode) this.parent).removeChild(this);

		// TODO: remove
		System.out.println("Send Node finished execution.");

	}
	
	/**
	 * Get the process definition of this node and its subnodes and return it.
	 * 
	 * @return
	 */
	public String getProcessDefinitions() {
		String str = "'" + channelName;
		String params = parameters.toString();
		params = params.substring(1,params.length()-1);
		str = str + "<" + params + ">";

		if (this.jjtGetNumChildren() > 0) {
			SimpleNode n = (SimpleNode) this.jjtGetChild(0);
			if (n != null) {
				str = str + "." + n.getProcessDefinitions();
			}
		}
		else
			str = str + ".0";
		return str;
	}

}
